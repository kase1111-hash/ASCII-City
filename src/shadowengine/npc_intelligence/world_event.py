"""
WorldEvent - Objective ground truth of what happened.

Events are generated by the engine and are never directly exposed to NPCs
or players. They serve as the source of truth from which memories and
rumors are derived.
"""

from dataclasses import dataclass, field
from typing import Optional, Any
from enum import Enum
import uuid


class WitnessType(Enum):
    """How an NPC witnessed an event."""
    DIRECT = "direct"           # Saw it happen
    INDIRECT = "indirect"       # Heard it (sound, told immediately after)
    INFERRED = "inferred"       # Figured it out from evidence


@dataclass
class Witness:
    """Record of who witnessed an event and how."""
    npc_id: str
    witness_type: WitnessType
    clarity: float = 1.0        # How clearly they perceived it (0-1)
    distance: float = 0.0       # How far away (affects memory accuracy)

    def to_dict(self) -> dict:
        return {
            "npc_id": self.npc_id,
            "witness_type": self.witness_type.value,
            "clarity": self.clarity,
            "distance": self.distance
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'Witness':
        data["witness_type"] = WitnessType(data["witness_type"])
        return cls(**data)


@dataclass
class WorldEvent:
    """
    Objective truth of what happened.

    This is the "god view" - what actually occurred regardless of who
    witnessed it or what anyone believes. The engine generates these,
    and they are never directly exposed to NPCs or players.
    """

    id: str = ""
    timestamp: float = 0.0
    location: tuple[int, int] = (0, 0)
    location_name: str = ""

    # What happened
    event_type: str = ""                    # injury, violence, theft, conversation, etc.
    actors: list[str] = field(default_factory=list)  # Who was involved
    details: dict[str, Any] = field(default_factory=dict)  # Objective facts

    # Witnesses
    witnesses: list[Witness] = field(default_factory=list)

    # Physical traces
    leaves_evidence: bool = False
    evidence_type: Optional[str] = None
    evidence_decay_rate: float = 0.01       # How fast evidence disappears

    # Propagation hints
    sound_radius: float = 0.0               # How far sound carried
    visual_range: float = 0.0               # How far it could be seen
    notability: float = 0.5                 # How noteworthy (affects spread)

    def __post_init__(self):
        if not self.id:
            self.id = f"evt_{uuid.uuid4().hex[:12]}"

    @property
    def direct_witnesses(self) -> list[str]:
        """Get NPCs who directly witnessed this event."""
        return [w.npc_id for w in self.witnesses
                if w.witness_type == WitnessType.DIRECT]

    @property
    def indirect_witnesses(self) -> list[str]:
        """Get NPCs who indirectly witnessed this event."""
        return [w.npc_id for w in self.witnesses
                if w.witness_type == WitnessType.INDIRECT]

    def add_witness(
        self,
        npc_id: str,
        witness_type: WitnessType,
        clarity: float = 1.0,
        distance: float = 0.0
    ) -> None:
        """Add a witness to this event."""
        self.witnesses.append(Witness(
            npc_id=npc_id,
            witness_type=witness_type,
            clarity=clarity,
            distance=distance
        ))

    def get_witness(self, npc_id: str) -> Optional[Witness]:
        """Get witness record for an NPC."""
        for w in self.witnesses:
            if w.npc_id == npc_id:
                return w
        return None

    def was_witnessed_by(self, npc_id: str) -> bool:
        """Check if NPC witnessed this event."""
        return any(w.npc_id == npc_id for w in self.witnesses)

    def to_dict(self) -> dict:
        """Serialize to dictionary."""
        return {
            "id": self.id,
            "timestamp": self.timestamp,
            "location": list(self.location),
            "location_name": self.location_name,
            "event_type": self.event_type,
            "actors": self.actors,
            "details": self.details,
            "witnesses": [w.to_dict() for w in self.witnesses],
            "leaves_evidence": self.leaves_evidence,
            "evidence_type": self.evidence_type,
            "evidence_decay_rate": self.evidence_decay_rate,
            "sound_radius": self.sound_radius,
            "visual_range": self.visual_range,
            "notability": self.notability
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'WorldEvent':
        """Deserialize from dictionary."""
        witnesses = [Witness.from_dict(w) for w in data.pop("witnesses", [])]
        data["location"] = tuple(data.get("location", [0, 0]))
        event = cls(**{k: v for k, v in data.items() if k != "witnesses"})
        event.witnesses = witnesses
        return event


class WorldEventFactory:
    """Factory for creating common event types."""

    @staticmethod
    def injury(
        timestamp: float,
        location: tuple[int, int],
        location_name: str,
        victim: str,
        severity: float,
        cause: str,
        witnesses: list[Witness] = None
    ) -> WorldEvent:
        """Create an injury event."""
        return WorldEvent(
            timestamp=timestamp,
            location=location,
            location_name=location_name,
            event_type="injury",
            actors=[victim],
            details={
                "severity": severity,
                "cause": cause,
                "result": "injured" if severity < 0.9 else "critical"
            },
            witnesses=witnesses or [],
            leaves_evidence=severity > 0.3,
            evidence_type="blood" if severity > 0.3 else None,
            sound_radius=5.0 if severity > 0.5 else 2.0,
            notability=severity
        )

    @staticmethod
    def violence(
        timestamp: float,
        location: tuple[int, int],
        location_name: str,
        attacker: str,
        victim: str,
        weapon: Optional[str] = None,
        lethal: bool = False,
        witnesses: list[Witness] = None
    ) -> WorldEvent:
        """Create a violence event."""
        return WorldEvent(
            timestamp=timestamp,
            location=location,
            location_name=location_name,
            event_type="violence",
            actors=[attacker, victim],
            details={
                "attacker": attacker,
                "victim": victim,
                "weapon": weapon,
                "result": "death" if lethal else "injury"
            },
            witnesses=witnesses or [],
            leaves_evidence=True,
            evidence_type="body" if lethal else "blood",
            sound_radius=15.0 if weapon == "pistol" else 5.0,
            visual_range=10.0,
            notability=1.0 if lethal else 0.7
        )

    @staticmethod
    def conversation(
        timestamp: float,
        location: tuple[int, int],
        location_name: str,
        participants: list[str],
        topic: str,
        tone: str = "neutral",
        witnesses: list[Witness] = None
    ) -> WorldEvent:
        """Create a conversation event."""
        return WorldEvent(
            timestamp=timestamp,
            location=location,
            location_name=location_name,
            event_type="conversation",
            actors=participants,
            details={
                "topic": topic,
                "tone": tone,
                "participant_count": len(participants)
            },
            witnesses=witnesses or [],
            leaves_evidence=False,
            sound_radius=3.0 if tone == "loud" else 1.0,
            notability=0.3 if tone == "neutral" else 0.5
        )

    @staticmethod
    def discovery(
        timestamp: float,
        location: tuple[int, int],
        location_name: str,
        discoverer: str,
        what: str,
        significance: float = 0.5,
        witnesses: list[Witness] = None
    ) -> WorldEvent:
        """Create a discovery event."""
        return WorldEvent(
            timestamp=timestamp,
            location=location,
            location_name=location_name,
            event_type="discovery",
            actors=[discoverer],
            details={
                "discovered": what,
                "significance": significance
            },
            witnesses=witnesses or [],
            leaves_evidence=False,
            notability=significance
        )

    @staticmethod
    def movement(
        timestamp: float,
        from_location: tuple[int, int],
        to_location: tuple[int, int],
        location_name: str,
        mover: str,
        manner: str = "normal",
        witnesses: list[Witness] = None
    ) -> WorldEvent:
        """Create a movement event."""
        return WorldEvent(
            timestamp=timestamp,
            location=to_location,
            location_name=location_name,
            event_type="movement",
            actors=[mover],
            details={
                "from": list(from_location),
                "to": list(to_location),
                "manner": manner  # running, sneaking, normal
            },
            witnesses=witnesses or [],
            leaves_evidence=False,
            sound_radius=5.0 if manner == "running" else 1.0,
            notability=0.3 if manner == "normal" else 0.5
        )

    @staticmethod
    def theft(
        timestamp: float,
        location: tuple[int, int],
        location_name: str,
        thief: str,
        victim: str,
        item: str,
        value: float = 0.5,
        witnesses: list[Witness] = None
    ) -> WorldEvent:
        """Create a theft event."""
        return WorldEvent(
            timestamp=timestamp,
            location=location,
            location_name=location_name,
            event_type="theft",
            actors=[thief, victim],
            details={
                "thief": thief,
                "victim": victim,
                "item": item,
                "value": value
            },
            witnesses=witnesses or [],
            leaves_evidence=False,
            notability=value
        )
