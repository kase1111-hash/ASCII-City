# ShadowEngine — NPC Memory & Rumor Propagation System

> **Version**: 1.0.0
> **Status**: Core Social Simulation
> **Purpose**: NPCs act on beliefs, not truth

---

## Design Goal (Hard Requirement)

**NPCs do not respond to the player.**
**NPCs respond to what they believe is true.**

Belief may be:
- **Wrong**
- **Incomplete**
- **Outdated**
- **Biased**
- **Dangerous**

**The player never sees "truth."**
**They see beliefs in motion.**

---

## Core Principles

| Principle | Implementation |
|-----------|----------------|
| Memory is local | Stored per NPC, per place |
| Memory decays | Confidence drops over time |
| Rumors mutate | Each retelling distorts content |
| NPCs have bias | Two NPCs hear same event → remember different things |
| Memory affects affordances | Who helps, attacks, lies, warns |

---

## System Overview

Three layers:

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│     EVENT                    MEMORY                  RUMOR       │
│  (ground truth)         (individual NPC)          (corrupted)    │
│                                                                  │
│  ┌───────────┐          ┌───────────┐          ┌───────────┐    │
│  │ Player    │          │ "Someone  │          │ "The      │    │
│  │ fell      │    →     │ fell near │    →     │ waterfall │    │
│  │ behind    │          │ the falls"│          │ kills     │    │
│  │ waterfall │          │           │          │ people"   │    │
│  └───────────┘          └───────────┘          └───────────┘    │
│                                                                  │
│  Engine-generated       NPC's interpretation   Mutated through   │
│  Never exposed          Subjective, decays     retelling         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1. Events (Ground Truth)

Events are generated by the engine. They are **never directly exposed** to NPCs or players.

### Event Schema

```python
@dataclass
class WorldEvent:
    """Objective truth of what happened."""

    id: str
    timestamp: float
    location: tuple[int, int]

    # What happened
    event_type: str
    actors: list[str]               # Who was involved
    details: dict[str, Any]         # Objective facts

    # Witnesses (who saw/heard it)
    direct_witnesses: list[str]     # NPCs who saw it
    indirect_witnesses: list[str]   # NPCs who heard it

    # Physical traces
    leaves_evidence: bool
    evidence_type: Optional[str]
```

### Example Events

```python
# Player slips behind waterfall
event_fall = WorldEvent(
    id="evt_48291",
    event_type="injury",
    location=(45, 23),
    actors=["player"],
    details={
        "action": "traversed",
        "target": "waterfall",
        "result": "slipped",
        "injury_severity": 0.6,
    },
    direct_witnesses=[],            # No one saw
    indirect_witnesses=["npc_fisherman"],  # Heard splash
    leaves_evidence=True,
    evidence_type="blood_on_rocks",
)

# Gunshot in alley
event_gunshot = WorldEvent(
    id="evt_48292",
    event_type="violence",
    location=(100, 50),
    actors=["thug_01", "victim_02"],
    details={
        "action": "shooting",
        "weapon": "pistol",
        "result": "death",
    },
    direct_witnesses=["npc_homeless"],
    indirect_witnesses=["npc_bartender", "npc_patron_1", "npc_patron_2"],
    leaves_evidence=True,
    evidence_type="body",
)
```

---

## 2. Memory (Individual NPC)

Each NPC stores **subjective memory objects**—their interpretation of events, not facts.

### Memory Object Schema

```python
@dataclass
class NPCMemory:
    """What an NPC believes happened."""

    # Reference
    event_id: Optional[str]         # May be null for rumors
    memory_id: str

    # Subjective content
    summary: str                    # NPC's interpretation, NOT fact
    tags: list[str]                 # ["danger", "water", "death"]

    # Confidence & emotion
    confidence: float               # 0.0-1.0: How sure they are
    emotional_weight: float         # 0.0-1.0: How much it affects them
    fear: float                     # 0.0-1.0: Fear associated
    anger: float                    # 0.0-1.0: Anger associated

    # Source
    trust_source: str               # "self", "friend", "rumor", "enemy"
    source_npc: Optional[str]       # Who told them (if not self)

    # Metadata
    timestamp: float                # When they learned it
    location: Optional[str]         # Where it happened
    last_recalled: float            # Last time they thought about it

    # Decay
    decay_rate: float               # How fast confidence drops
```

### Memory Schema (JSON)

```json
{
  "event_id": "evt_48291",
  "memory_id": "mem_192847",
  "summary": "Someone fell near the waterfall",
  "tags": ["danger", "water", "death"],
  "confidence": 0.6,
  "emotional_weight": 0.7,
  "fear": 0.4,
  "anger": 0.0,
  "trust_source": "self",
  "source_npc": null,
  "timestamp": 122304,
  "location": "north_falls",
  "last_recalled": 122500,
  "decay_rate": 0.01
}
```

### Key Fields Explained

| Field | Meaning |
|-------|---------|
| `summary` | NPC's interpretation, **not fact** |
| `emotional_weight` | How often they recall/share it |
| `confidence` | How sure they are it happened |
| `fear` | Modifies behavior & speech |
| `trust_source` | "self" (saw it), "friend", "rumor", "enemy" |
| `tags` | Used for rumor matching & behavior |

---

## 3. NPC Memory System

### Memory Capacity

**NPCs have limited memory slots.** This creates forgetfulness, obsession, and bias loops.

```python
NPC_MEMORY_CAPACITY = {
    "civilian": 10,
    "bartender": 25,
    "informant": 40,
    "cop": 35,
    "mob_boss": 60,
    "street_urchin": 15,
}
```

### Memory Decay

```python
class MemoryDecaySystem:
    """Memories fade over time."""

    def decay_memories(self, npc: NPC, dt: float) -> None:
        """Apply decay to all NPC memories."""

        for memory in npc.memories:
            # Base decay
            decay = memory.decay_rate * dt

            # Emotional memories decay slower
            decay *= (1.0 - memory.emotional_weight * 0.5)

            # Traumatic memories barely decay
            if memory.fear > 0.8 or memory.tags.contains("trauma"):
                decay *= 0.1

            memory.confidence -= decay

    def prune_memories(self, npc: NPC) -> None:
        """Remove faded memories when at capacity."""

        if len(npc.memories) <= npc.memory_capacity:
            return

        # Sort by retention priority
        npc.memories.sort(key=lambda m: self._retention_priority(m))

        # Remove lowest priority until under capacity
        while len(npc.memories) > npc.memory_capacity:
            removed = npc.memories.pop(0)
            # Low-confidence memories go first

    def _retention_priority(self, memory: NPCMemory) -> float:
        """Higher = kept longer."""
        return (
            memory.confidence * 0.3 +
            memory.emotional_weight * 0.4 +
            memory.fear * 0.2 +
            (1.0 if memory.trust_source == "self" else 0.5) * 0.1
        )
```

### Memory Formation

```python
class MemoryFormation:
    """How NPCs form memories from events."""

    def witness_event(
        self,
        npc: NPC,
        event: WorldEvent,
        witness_type: str,  # "direct" or "indirect"
    ) -> NPCMemory:
        """NPC witnesses an event, forms memory."""

        # Direct witnesses have higher confidence
        if witness_type == "direct":
            base_confidence = 0.9
            trust_source = "self"
        else:
            base_confidence = 0.5
            trust_source = "self"  # Still witnessed, just heard

        # Apply NPC bias to interpretation
        summary = self._interpret_event(npc, event)
        tags = self._extract_tags(event, npc.bias)
        emotional_weight = self._calculate_emotion(npc, event)

        memory = NPCMemory(
            event_id=event.id,
            memory_id=self._generate_id(),
            summary=summary,
            tags=tags,
            confidence=base_confidence * npc.perception_accuracy,
            emotional_weight=emotional_weight,
            fear=self._calculate_fear(npc, event),
            anger=self._calculate_anger(npc, event),
            trust_source=trust_source,
            timestamp=event.timestamp,
            location=event.location,
            decay_rate=0.01,
        )

        npc.memories.append(memory)
        return memory

    def _interpret_event(self, npc: NPC, event: WorldEvent) -> str:
        """NPC interprets event through their bias."""

        # Same event, different interpretations
        if event.event_type == "injury":
            if npc.bias.fearful > 0.7:
                return "Someone nearly died there"
            elif npc.bias.curious > 0.7:
                return "There was an accident at the falls"
            else:
                return "Someone got hurt"

        if event.event_type == "violence":
            if npc.bias.paranoid > 0.7:
                return "The mob is killing people"
            elif npc.bias.loyal > 0.7 and event.actors[0] in npc.allies:
                return "Someone was defending themselves"
            else:
                return "There was a shooting"

        return f"Something happened at {event.location}"
```

---

## 4. Rumors (Shared, Corrupted Memory)

A rumor is **a memory that has left its original owner** and mutated through retelling.

### Rumor Schema

```python
@dataclass
class Rumor:
    """A propagating, mutating piece of information."""

    rumor_id: str

    # Content
    core_claim: str                 # The main assertion
    details: list[str]              # Supporting details (may be wrong)
    tags: list[str]

    # Propagation state
    confidence: float               # How believed it is
    distortion: float               # How far from truth (0.0 = accurate)
    spread_count: int               # How many times retold
    carrier_count: int              # How many NPCs know it

    # Origin
    origin_event: Optional[str]     # Original event ID (may be lost)
    origin_location: str
    origin_timestamp: float

    # Current state
    last_updated: float
    is_active: bool                 # Still spreading?
```

### Rumor Schema (JSON)

```json
{
  "rumor_id": "rum_8472",
  "core_claim": "The waterfall kills people",
  "details": ["Someone died there", "The rocks are sharp"],
  "tags": ["danger", "death", "waterfall"],
  "confidence": 0.4,
  "distortion": 0.3,
  "spread_count": 5,
  "carrier_count": 8,
  "origin_event": "evt_48291",
  "origin_location": "north_falls",
  "origin_timestamp": 122304,
  "last_updated": 122980,
  "is_active": true
}
```

---

## 5. Rumor Propagation

### When Rumors Spread

```python
class RumorPropagationTriggers:
    """Conditions that cause rumor transmission."""

    TRIGGERS = [
        "npcs_converse",        # Natural conversation
        "npcs_overhear",        # One NPC near another
        "npcs_drink",           # At bar, alcohol loosens tongues
        "npcs_gossip",          # Idle chatter
        "npc_threatened",       # Fear makes them talk
        "npc_bribed",           # Money makes them talk
        "npc_interrogated",     # Pressure makes them talk
    ]

    def should_propagate(
        self,
        source_npc: NPC,
        target_npc: NPC,
        context: str,
    ) -> bool:
        """Determine if rumor spreads in this interaction."""

        # Base probability by context
        base_prob = {
            "npcs_converse": 0.3,
            "npcs_drink": 0.6,
            "npcs_gossip": 0.8,
            "npc_threatened": 0.9,
            "npc_bribed": 0.95,
        }.get(context, 0.2)

        # Modify by relationship
        if target_npc.id in source_npc.friends:
            base_prob *= 1.5
        if target_npc.id in source_npc.enemies:
            base_prob *= 0.3

        # Modify by source personality
        base_prob *= source_npc.bias.get("talkative", 0.5) + 0.5

        return random() < min(1.0, base_prob)
```

### Rumor Mutation

**Each transmission applies mutation.** Details change, emotions shift, attributions wander.

```python
class RumorMutation:
    """How rumors change as they spread."""

    def mutate(
        self,
        rumor: Rumor,
        source_npc: NPC,
        target_npc: NPC,
    ) -> Rumor:
        """Apply mutation when rumor transfers between NPCs."""

        mutated = copy(rumor)

        # Confidence decreases slightly
        mutated.confidence *= 0.9

        # Distortion increases
        mutated.distortion = min(1.0, mutated.distortion + 0.1)

        # Track spread
        mutated.spread_count += 1

        # Apply source bias to content
        mutated.core_claim = self._apply_source_bias(
            rumor.core_claim,
            source_npc.bias,
        )

        # Apply target bias to reception
        mutated.details = self._filter_by_target_bias(
            rumor.details,
            target_npc.bias,
        )

        # Possible mutations
        if random() < 0.2:
            mutated = self._simplify(mutated)
        if random() < 0.15:
            mutated = self._exaggerate(mutated, source_npc.bias)
        if random() < 0.1:
            mutated = self._personalize(mutated, source_npc, target_npc)
        if random() < 0.1:
            mutated = self._misattribute(mutated)

        mutated.last_updated = self.current_time

        return mutated

    def _simplify(self, rumor: Rumor) -> Rumor:
        """Remove details, keep core claim."""
        rumor.details = rumor.details[:max(1, len(rumor.details) - 1)]
        return rumor

    def _exaggerate(self, rumor: Rumor, bias: NPCBias) -> Rumor:
        """Make it more dramatic."""
        EXAGGERATIONS = {
            "Someone got hurt": "Someone nearly died",
            "Someone nearly died": "Someone died",
            "There was a shooting": "There was a massacre",
            "The waterfall is dangerous": "The waterfall kills people",
        }
        if rumor.core_claim in EXAGGERATIONS:
            if bias.fearful > 0.5 or bias.dramatic > 0.5:
                rumor.core_claim = EXAGGERATIONS[rumor.core_claim]
                rumor.distortion += 0.1
        return rumor

    def _personalize(self, rumor: Rumor, source: NPC, target: NPC) -> Rumor:
        """Add personal connection."""
        # "I heard..." becomes "My cousin saw..."
        if "stranger" in rumor.core_claim:
            if random() < 0.3:
                rumor.details.append("Someone I know was there")
        return rumor

    def _misattribute(self, rumor: Rumor) -> Rumor:
        """Blame the wrong person/cause."""
        MISATTRIBUTIONS = {
            "accident": "murder",
            "fell": "was pushed",
            "stranger": "that detective",
            "someone": "the mob",
        }
        for old, new in MISATTRIBUTIONS.items():
            if old in rumor.core_claim.lower():
                if random() < 0.3:
                    rumor.core_claim = rumor.core_claim.replace(old, new)
                    rumor.distortion += 0.2
                    break
        return rumor
```

### Mutation Chain Example

```
EVENT (Ground Truth):
  Player slips behind waterfall, survives badly injured

MEMORY A (Fisherman who heard splash):
  "I heard someone almost died back there."
  confidence: 0.5, fear: 0.3

RUMOR B (Fisherman tells bartender):
  "They say someone nearly died at the waterfall."
  confidence: 0.45, distortion: 0.1

RUMOR C (Bartender tells drunk):
  "The waterfall is dangerous. Kills people."
  confidence: 0.4, distortion: 0.3
  [Exaggeration applied]

RUMOR D (Drunk tells patron):
  "The mob dumps bodies behind the falls."
  confidence: 0.35, distortion: 0.5
  [Misattribution applied]

RUMOR E (Patron tells cop):
  "That detective? He's mixed up with the falls."
  confidence: 0.3, distortion: 0.7
  [Personalization + misattribution]
```

**None are lies. None are true. All are dangerous.**

---

## 6. NPC Bias System

Each NPC has **bias coefficients** that affect perception, memory, and rumor transmission.

### Bias Schema

```python
@dataclass
class NPCBias:
    """Personality traits that affect information processing."""

    # Fear & caution
    fearful: float          # 0.0-1.0: Sees danger everywhere
    paranoid: float         # 0.0-1.0: Suspects conspiracies

    # Social
    loyal: float            # 0.0-1.0: Protects allies in retelling
    talkative: float        # 0.0-1.0: Shares information freely

    # Self-interest
    greedy: float           # 0.0-1.0: Focuses on profit angles
    self_preserving: float  # 0.0-1.0: Omits self-incriminating details

    # Perception
    curious: float          # 0.0-1.0: Seeks more information
    dramatic: float         # 0.0-1.0: Exaggerates for effect
    cynical: float          # 0.0-1.0: Assumes worst motives

    # Trust
    trusting: float         # 0.0-1.0: Believes what they hear
    suspicious: float       # 0.0-1.0: Questions everything
```

### Bias Application

```python
class BiasProcessor:
    """How bias affects NPC information processing."""

    def apply_to_memory(self, npc: NPC, memory: NPCMemory) -> NPCMemory:
        """Apply bias when forming memory."""

        bias = npc.bias

        # Fearful NPCs remember things as more dangerous
        if bias.fearful > 0.6:
            memory.fear += 0.2
            if "danger" not in memory.tags:
                memory.tags.append("danger")

        # Paranoid NPCs see conspiracies
        if bias.paranoid > 0.7:
            if random() < 0.3:
                memory.tags.append("conspiracy")
                memory.summary = self._add_conspiracy_angle(memory.summary)

        # Loyal NPCs protect allies
        if bias.loyal > 0.6:
            memory.summary = self._soften_ally_involvement(
                memory.summary, npc.allies
            )

        return memory

    def apply_to_rumor(self, npc: NPC, rumor: Rumor) -> Rumor:
        """Apply bias when retelling rumor."""

        bias = npc.bias

        # Dramatic NPCs exaggerate
        if bias.dramatic > 0.6:
            rumor.core_claim = self._dramatize(rumor.core_claim)

        # Greedy NPCs add profit angles
        if bias.greedy > 0.6:
            if random() < 0.4:
                rumor.details.append("There's money involved")

        # Self-preserving NPCs omit self-incrimination
        if bias.self_preserving > 0.7:
            rumor.details = [d for d in rumor.details
                           if npc.name not in d]

        return rumor
```

### Same Rumor, Different Tellers

```python
# Original rumor: "Someone got shot in the alley"

# Bartender (talkative: 0.8, self_preserving: 0.9)
bartender_version = "Yeah, I heard something. Didn't see nothing though."

# Drunk (dramatic: 0.9, fearful: 0.7)
drunk_version = "Blood everywhere! They're killing people out there!"

# Cop (paranoid: 0.6, suspicious: 0.8)
cop_version = "Another mob hit. This connects to something bigger."

# Mobster (loyal: 0.9, self_preserving: 0.95)
mobster_version = "Some punk got what was coming. Nothing to do with us."
```

---

## 7. Memory → Behavior Mapping

**NPC memories directly alter their affordances toward the player.**

### Memory Tag → Behavior

```python
MEMORY_BEHAVIOR_MAPPING = {
    # Danger perception
    "danger": {
        "behavior": "avoid_area",
        "affordance_mod": {"helps": -0.3},
    },
    "death_here": {
        "behavior": "warn_player",
        "affordance_mod": {"helps": +0.1},
    },

    # Player perception
    "player_suspicious": {
        "behavior": "lie_to_player",
        "affordance_mod": {"trusts": -0.4, "reveals": -0.5},
    },
    "player_violent": {
        "behavior": "flee_from_player",
        "affordance_mod": {"threatens": +0.3, "cooperates": -0.6},
    },
    "player_helpful": {
        "behavior": "help_player",
        "affordance_mod": {"trusts": +0.3, "reveals": +0.2},
    },
    "player_trustworthy": {
        "behavior": "confide_in_player",
        "affordance_mod": {"reveals": +0.5},
    },

    # External threats
    "mob_involved": {
        "behavior": "silence",
        "affordance_mod": {"reveals": -0.8, "fears": +0.5},
    },
    "cops_watching": {
        "behavior": "act_normal",
        "affordance_mod": {"suspicious_actions": -0.5},
    },
}


class MemoryBehaviorSystem:
    """Translate memories into behavior changes."""

    def update_npc_behavior(self, npc: NPC) -> None:
        """Update NPC behavior based on memories."""

        # Aggregate effects from all memories
        total_mods = {}

        for memory in npc.memories:
            for tag in memory.tags:
                if tag in MEMORY_BEHAVIOR_MAPPING:
                    mapping = MEMORY_BEHAVIOR_MAPPING[tag]

                    # Weight by confidence and recency
                    weight = memory.confidence * self._recency_weight(memory)

                    for affordance, mod in mapping["affordance_mod"].items():
                        total_mods[affordance] = total_mods.get(affordance, 0)
                        total_mods[affordance] += mod * weight

        # Apply to NPC
        npc.behavior_modifiers = total_mods

    def get_npc_response_to_player(self, npc: NPC, player: Player) -> str:
        """Determine NPC's behavioral response."""

        mods = npc.behavior_modifiers

        if mods.get("fears", 0) > 0.5:
            return "flee"
        if mods.get("trusts", 0) > 0.5:
            return "help"
        if mods.get("reveals", 0) < -0.5:
            return "lie"
        if mods.get("cooperates", 0) < -0.3:
            return "refuse"

        return "neutral"
```

---

## 8. Environmental Memory (Tile Memory)

**Places remember things too.** (Dwarf Fortress-inspired)

### Tile Memory Schema

```python
@dataclass
class TileMemory:
    """What has happened at this location."""

    location: tuple[int, int]

    # Events that happened here
    event_history: list[str]        # Event IDs
    event_tags: set[str]            # Aggregated tags

    # Derived metrics
    rumor_density: float            # How much people talk about this place
    danger_rating: float            # Perceived danger
    activity_level: float           # How busy/quiet

    # Effects
    npc_avoidance: float            # NPCs avoid this area
    npc_curiosity: float            # NPCs investigate this area

    # Last update
    last_event: float
    decay_rate: float
```

### Tile Memory (JSON)

```json
{
  "location": [45, 23],
  "event_history": ["evt_48291", "evt_48305"],
  "event_tags": ["danger", "water", "death", "blood"],
  "rumor_density": 0.7,
  "danger_rating": 0.6,
  "activity_level": 0.3,
  "npc_avoidance": 0.5,
  "npc_curiosity": 0.2,
  "last_event": 122980,
  "decay_rate": 0.005
}
```

### Tile Memory Effects

```python
class TileMemoryEffects:
    """How tile memory affects the game."""

    def affect_npc_pathing(
        self,
        npc: NPC,
        path: list[tuple[int, int]],
        tile_memories: dict[tuple, TileMemory],
    ) -> list[tuple[int, int]]:
        """NPCs avoid dangerous remembered locations."""

        modified_path = []

        for tile_pos in path:
            memory = tile_memories.get(tile_pos)

            if memory and memory.npc_avoidance > 0.5:
                # Try to find alternative
                alternative = self._find_safer_route(tile_pos, npc)
                if alternative:
                    modified_path.extend(alternative)
                    continue

            modified_path.append(tile_pos)

        return modified_path

    def affect_dialogue_tone(
        self,
        location: tuple[int, int],
        tile_memories: dict[tuple, TileMemory],
    ) -> str:
        """Location memory affects how NPCs speak here."""

        memory = tile_memories.get(location)

        if not memory:
            return "neutral"

        if memory.danger_rating > 0.7:
            return "whispered"      # NPCs speak quietly
        if memory.rumor_density > 0.6:
            return "gossipy"        # NPCs share info freely
        if "death" in memory.event_tags:
            return "somber"         # NPCs are subdued

        return "neutral"

    def affect_llm_description(
        self,
        location: tuple[int, int],
        tile_memories: dict[tuple, TileMemory],
    ) -> list[str]:
        """Provide hints to LLM for scene description."""

        memory = tile_memories.get(location)
        hints = []

        if memory:
            if memory.danger_rating > 0.5:
                hints.append("This place feels dangerous")
            if "blood" in memory.event_tags:
                hints.append("There are dark stains on the ground")
            if memory.npc_avoidance > 0.6:
                hints.append("People don't linger here")
            if memory.rumor_density > 0.7:
                hints.append("This place has a reputation")

        return hints
```

---

## 9. LLM Integration

**The LLM does not invent lore. It selects from memories, rumors, and bias.**

### LLM Prompt Construction

```python
class NPCDialogueLLM:
    """Generate NPC dialogue using memory system."""

    async def generate_dialogue(
        self,
        npc: NPC,
        player: Player,
        context: DialogueContext,
    ) -> str:
        """Generate what NPC says based on their memories."""

        # Gather NPC's relevant memories
        relevant_memories = self._get_relevant_memories(npc, context.topic)

        # Gather rumors NPC knows
        known_rumors = self._get_known_rumors(npc, context.topic)

        # Calculate trust level toward player
        trust = self._calculate_trust(npc, player)

        # Build prompt
        prompt = f"""
You are an NPC with these memories:
{self._format_memories(relevant_memories)}

You have heard these rumors:
{self._format_rumors(known_rumors)}

Your personality:
- Fearful: {npc.bias.fearful}
- Paranoid: {npc.bias.paranoid}
- Talkative: {npc.bias.talkative}

You are speaking to: the player
Your trust toward them: {trust}

Current topic: {context.topic}

RULES:
- Answer naturally based on what you BELIEVE
- Do not reveal certainty—you're not omniscient
- If trust is low, be evasive or lie
- If fearful, underplay what you know
- If paranoid, hint at conspiracies

Respond in 1-2 sentences. Noir style.
"""

        return await self.llm.generate(prompt)

    def _get_relevant_memories(
        self,
        npc: NPC,
        topic: str,
    ) -> list[NPCMemory]:
        """Get memories related to topic."""

        relevant = []
        topic_tags = self._topic_to_tags(topic)

        for memory in npc.memories:
            if any(tag in memory.tags for tag in topic_tags):
                relevant.append(memory)

        # Sort by relevance and confidence
        relevant.sort(key=lambda m: m.confidence * m.emotional_weight, reverse=True)

        return relevant[:5]  # Limit context size
```

### What This Prevents

| Problem | How Memory System Prevents It |
|---------|-------------------------------|
| Omniscience | NPC only knows what they've witnessed/heard |
| Canon breaks | Memories are subjective, not authoritative |
| Retcon nonsense | History is remembered, not invented |
| Perfect information | Rumors are distorted, memories decay |

---

## 10. Player Interaction With Rumors

**The player can manipulate the rumor system.** This creates emergent gameplay.

### Player Actions

```python
class PlayerRumorActions:
    """Ways player can affect rumors."""

    def spread_false_rumor(
        self,
        player: Player,
        target_npc: NPC,
        rumor_content: str,
    ) -> Rumor:
        """Player deliberately spreads misinformation."""

        rumor = Rumor(
            core_claim=rumor_content,
            confidence=0.5 * player.reputation.credibility,
            distortion=0.0,  # Player knows it's false
            origin_location=player.location,
        )

        target_npc.receive_rumor(rumor, source="player")
        return rumor

    def reinforce_rumor(
        self,
        player: Player,
        npc: NPC,
        existing_rumor: Rumor,
    ) -> None:
        """Player confirms an existing rumor, increasing its spread."""

        # Find NPC's version of rumor
        npc_rumor = npc.get_rumor_matching(existing_rumor)

        if npc_rumor:
            npc_rumor.confidence += 0.2
            npc_rumor.emotional_weight += 0.1
            # More likely to spread

    def silence_npc(
        self,
        player: Player,
        npc: NPC,
        method: str,  # "threaten", "bribe", "kill"
    ) -> bool:
        """Player prevents NPC from spreading rumors."""

        if method == "threaten":
            if player.threat_level > npc.courage:
                npc.add_memory(NPCMemory(
                    summary="The detective threatened me",
                    tags=["player_violent", "fear"],
                    fear=0.8,
                ))
                npc.rumor_spread_rate *= 0.1  # Silenced
                return True

        elif method == "bribe":
            if player.money >= npc.bribe_threshold:
                player.money -= npc.bribe_threshold
                npc.rumor_spread_rate *= 0.3
                return True

        elif method == "kill":
            # Permanent silence, but creates new event
            self.kill_npc(npc)
            return True

        return False

    def create_fear_cascade(
        self,
        player: Player,
        initial_action: str,
    ) -> list[Rumor]:
        """Player action creates spreading fear."""

        # Example: Player is seen running from multiple crime scenes
        # Rumor forms: "He's dangerous, but smart"

        event = WorldEvent(
            event_type="player_flees",
            actors=["player"],
            # ...
        )

        # Witnesses form memories
        # Memories become rumors
        # Rumors spread and mutate
        # Eventually: NPCs treat player differently

        return self.propagation_engine.process_event(event)
```

### Example: Rumor Manipulation

```
SCENARIO: Player is innocent but needs to look guilty

ACTION: Player tells bartender "I was at the docks last night"

RESULT:
1. Bartender forms memory: "Detective was at docks"
2. Bartender tells drunk: "Detective was at the docks"
3. Drunk tells patron: "Detective was at the docks—doing what?"
4. Patron tells cop: "That detective? He's mixed up with the docks business"

CONSEQUENCE:
- Cops now watching player
- Mob thinks player is investigating them
- Real killer relaxes (heat is elsewhere)
```

---

## 11. Failure Is Story

**Incorrect rumors create consequences, not error states.**

### Consequences of Bad Information

```python
class RumorConsequences:
    """Bad rumors lead to bad outcomes."""

    CONSEQUENCE_MAP = {
        # Rumor about player being violent
        "player_violent": [
            "npc_attacks_preemptively",
            "cops_arrive_hostile",
            "allies_abandon",
            "witnesses_flee",
        ],

        # Rumor about player being cop
        "player_is_cop": [
            "informants_clam_up",
            "criminals_hide",
            "mob_targets_player",
        ],

        # Rumor about player being mob
        "player_is_mob": [
            "civilians_flee",
            "cops_investigate",
            "rival_mob_attacks",
        ],

        # Rumor about location being dangerous
        "location_dangerous": [
            "npcs_avoid_area",
            "witnesses_gone",
            "evidence_ignored",
        ],
    }

    def apply_consequences(
        self,
        rumor: Rumor,
        world: WorldGrid,
    ) -> list[Consequence]:
        """Apply consequences when rumor reaches critical mass."""

        consequences = []

        if rumor.carrier_count > 5 and rumor.confidence > 0.4:
            # Rumor has spread enough to have effects
            for tag in rumor.tags:
                if tag in self.CONSEQUENCE_MAP:
                    for consequence in self.CONSEQUENCE_MAP[tag]:
                        consequences.append(
                            self._create_consequence(consequence, rumor)
                        )

        return consequences
```

### The Engine Never Corrects Rumors

```python
class RumorTruth:
    """The engine does not correct misinformation."""

    def should_correct_rumor(self, rumor: Rumor) -> bool:
        """Always returns False. Only consequences correct."""
        return False

    def how_rumors_die(self) -> list[str]:
        """Ways rumors stop spreading naturally."""
        return [
            "carrier_dies",                # Silence the source
            "counter_rumor_spreads",       # New rumor contradicts
            "evidence_found",              # Physical proof emerges
            "time_passes",                 # People forget
            "more_interesting_rumor",      # Displaced by juicier gossip
        ]
```

---

## 12. Implementation Phases

### Phase 1: Core Memory

```
- NPC memory list with decay
- Memory formation from events
- Basic behavior modifiers
- LLM dialogue uses memories
```

### Phase 2: Rumors

```
- Rumor object and propagation
- Mutation on transfer
- Bias-based distortion
- Carrier tracking
```

### Phase 3: Environmental

```
- Tile memory system
- NPC pathing affected by tile history
- LLM uses tile hints
- Rumor density visualization
```

### Phase 4: Player Agency

```
- Player can spread rumors
- Silence/bribe mechanics
- Fear cascade system
- Reputation tracking
```

---

## 13. Why This System Is Special

| Most Games | ShadowEngine |
|------------|--------------|
| NPCs respond to flags | NPCs act on beliefs |
| Information is binary | Information decays and mutates |
| Player sees truth | Player sees beliefs in motion |
| Dialogue is scripted | Dialogue emerges from memory |
| Mistakes are errors | Mistakes are stories |

**This is the difference between:**

```
A scripted world
```

**and**

```
A self-lying world
```

---

*End of NPC Memory & Rumor Propagation System*
